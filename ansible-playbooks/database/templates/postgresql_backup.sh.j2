#!/bin/bash
# PostgreSQL 数据库备份脚本
# 由 Ansible 自动生成 - 请勿手动编辑
# 生成时间: {{ ansible_date_time.iso8601 }}

set -euo pipefail

# ============================================================================
# 配置变量
# ============================================================================
BACKUP_DIR="{{ postgresql_backup_dir }}"
BACKUP_TYPE="{{ postgresql_backup_type }}"
BACKUP_COMPRESS="{{ postgresql_backup_compress | lower }}"
BACKUP_COMPRESS_METHOD="{{ postgresql_backup_compress_method }}"
BACKUP_FORMAT="{{ postgresql_backup_format }}"
RETENTION_DAYS="{{ postgresql_backup_retention_days }}"
PG_HOST="localhost"
PG_PORT="{{ postgresql_port }}"
PG_USER="{{ postgresql_backup_user }}"

# WAL 归档配置
WAL_ARCHIVE_ENABLED="{{ postgresql_wal_archive_enabled | default(false) | lower }}"
WAL_ARCHIVE_DIR="{{ postgresql_wal_archive_dir | default('') }}"

# 日志文件
LOG_FILE="${BACKUP_DIR}/logs/backup.log"
DATE=$(date +%Y%m%d_%H%M%S)
TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")

# 备份类型参数
BACKUP_SUBDIR="daily"
if [ "${1:-daily}" = "weekly" ]; then
    BACKUP_SUBDIR="weekly"
elif [ "${1:-daily}" = "monthly" ]; then
    BACKUP_SUBDIR="monthly"
fi

# ============================================================================
# 函数定义
# ============================================================================

# 日志函数
log() {
    echo "[${TIMESTAMP}] $1" | tee -a "${LOG_FILE}"
}

# 错误处理函数
error_exit() {
    log "错误: $1"
    exit 1
}

# 检查命令是否存在
check_command() {
    if ! command -v "$1" &> /dev/null; then
        error_exit "命令 $1 未找到，请先安装 PostgreSQL 客户端工具"
    fi
}

# 获取数据库列表
get_databases() {
    psql -h "${PG_HOST}" -p "${PG_PORT}" -U "${PG_USER}" -tAc \
        "SELECT datname FROM pg_database WHERE datistemplate = false AND datname != 'postgres';" \
        2>/dev/null || true
}

# 逻辑备份函数（使用 pg_dump）
logical_backup() {
    local db=$1
    local backup_file="${BACKUP_DIR}/${BACKUP_SUBDIR}/${db}_${DATE}"
    
    log "开始备份数据库: ${db}"
    
    # 根据格式选择文件扩展名
    case "${BACKUP_FORMAT}" in
        plain)
            backup_file="${backup_file}.sql"
            ;;
        custom)
            backup_file="${backup_file}.dump"
            ;;
        directory)
            backup_file="${backup_file}.dir"
            ;;
        tar)
            backup_file="${backup_file}.tar"
            ;;
    esac
    
    # 执行备份
    if pg_dump -h "${PG_HOST}" -p "${PG_PORT}" -U "${PG_USER}" \
        -F "${BACKUP_FORMAT:0:1}" \
        -f "${backup_file}" \
        "${db}" 2>> "${LOG_FILE}"; then
        
        # 压缩备份文件（仅对 plain 和 tar 格式）
        if [ "${BACKUP_COMPRESS}" = "true" ] && [ "${BACKUP_FORMAT}" != "custom" ] && [ "${BACKUP_FORMAT}" != "directory" ]; then
            log "压缩备份文件: ${backup_file}"
            case "${BACKUP_COMPRESS_METHOD}" in
                gzip)
                    gzip -f "${backup_file}" && backup_file="${backup_file}.gz"
                    ;;
                custom)
                    # custom 格式已经内置压缩
                    :
                    ;;
            esac
        fi
        
        log "备份完成: ${backup_file}"
        if [ -f "${backup_file}" ]; then
            log "备份大小: $(du -h "${backup_file}" | cut -f1)"
        elif [ -d "${backup_file}" ]; then
            log "备份大小: $(du -sh "${backup_file}" | cut -f1)"
        fi
        return 0
    else
        error_exit "备份失败: ${db}"
    fi
}

# 全库备份函数
full_backup() {
    local backup_file="${BACKUP_DIR}/${BACKUP_SUBDIR}/all_databases_${DATE}.sql"
    
    log "开始全库备份（使用 pg_dumpall）"
    
    if pg_dumpall -h "${PG_HOST}" -p "${PG_PORT}" -U "${PG_USER}" \
        -f "${backup_file}" 2>> "${LOG_FILE}"; then
        
        # 压缩备份文件
        if [ "${BACKUP_COMPRESS}" = "true" ]; then
            log "压缩备份文件: ${backup_file}"
            gzip -f "${backup_file}" && backup_file="${backup_file}.gz"
        fi
        
        log "全库备份完成: ${backup_file}"
        log "备份大小: $(du -h "${backup_file}" | cut -f1)"
        return 0
    else
        error_exit "全库备份失败"
    fi
}

# 物理备份函数（使用 pg_basebackup）
basebackup() {
    local backup_dir="${BACKUP_DIR}/${BACKUP_SUBDIR}/basebackup_${DATE}"
    
    log "开始物理备份（pg_basebackup）"
    
    mkdir -p "${backup_dir}"
    
    if pg_basebackup -h "${PG_HOST}" -p "${PG_PORT}" -U "${PG_USER}" \
        -D "${backup_dir}" \
        -Ft -z -P 2>> "${LOG_FILE}"; then
        
        log "物理备份完成: ${backup_dir}"
        log "备份大小: $(du -sh "${backup_dir}" | cut -f1)"
        return 0
    else
        error_exit "物理备份失败"
    fi
}

# WAL 归档清理
cleanup_wal_archive() {
    if [ "${WAL_ARCHIVE_ENABLED}" = "true" ] && [ -n "${WAL_ARCHIVE_DIR}" ] && [ -d "${WAL_ARCHIVE_DIR}" ]; then
        log "清理 WAL 归档文件（保留 ${RETENTION_DAYS} 天）"
        find "${WAL_ARCHIVE_DIR}" -type f -mtime +${RETENTION_DAYS} -delete 2>> "${LOG_FILE}" || true
    fi
}

# 清理旧备份
cleanup_old_backups() {
    log "清理 ${RETENTION_DAYS} 天前的备份文件"
    find "${BACKUP_DIR}/${BACKUP_SUBDIR}" -type f -mtime +${RETENTION_DAYS} -delete 2>> "${LOG_FILE}" || true
    find "${BACKUP_DIR}/${BACKUP_SUBDIR}" -type d -empty -delete 2>> "${LOG_FILE}" || true
    log "清理完成"
}

# ============================================================================
# 主程序
# ============================================================================

main() {
    log "=========================================="
    log "PostgreSQL 数据库备份开始 (${BACKUP_SUBDIR})"
    log "=========================================="
    
    # 检查必需命令
    check_command psql
    check_command pg_dump
    check_command pg_dumpall
    
    # 创建备份目录
    mkdir -p "${BACKUP_DIR}/${BACKUP_SUBDIR}" "${BACKUP_DIR}/logs"
    
    # 检查磁盘空间
    DISK_USAGE=$(df -h "${BACKUP_DIR}" | tail -1 | awk '{print $5}' | sed 's/%//')
    log "备份磁盘使用率: ${DISK_USAGE}%"
    if [ "${DISK_USAGE}" -gt 90 ]; then
        log "警告: 备份磁盘空间不足 (使用率: ${DISK_USAGE}%)"
    fi
    
    # 执行备份
    if [ "${BACKUP_TYPE}" = "basebackup" ]; then
        # 物理备份
        basebackup
    else
        # 逻辑备份
{% if postgresql_backup_databases | default([]) | length > 0 %}
        # 备份指定数据库
{% for db in postgresql_backup_databases %}
        logical_backup "{{ db }}"
{% endfor %}
{% else %}
        # 备份所有数据库
        DATABASE_LIST=$(get_databases)
        
        if [ -z "${DATABASE_LIST}" ]; then
            log "未找到用户数据库，执行全库备份"
            full_backup
        else
            for db in ${DATABASE_LIST}; do
                logical_backup "${db}"
            done
            
            # 同时备份全局对象（角色、表空间等）
            log "备份全局对象"
            pg_dumpall -h "${PG_HOST}" -p "${PG_PORT}" -U "${PG_USER}" \
                --globals-only -f "${BACKUP_DIR}/${BACKUP_SUBDIR}/globals_${DATE}.sql" 2>> "${LOG_FILE}" || true
        fi
{% endif %}
    fi
    
    # 清理 WAL 归档
    cleanup_wal_archive
    
    # 清理旧备份
    cleanup_old_backups
    
    log "=========================================="
    log "PostgreSQL 数据库备份完成"
    log "=========================================="
}

# 执行主程序
main "$@"
